#if os(macOS)
import SystemConfiguration
#endif
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(aries_askarFFI)
import aries_askarFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_aries_askar_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_aries_askar_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol AskarCryptoProtocol {
    func `boxOpen`(`receiverKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8])  throws -> [UInt8]
    func `boxSeal`(`receiverKey`: AskarLocalKey, `message`: [UInt8])  throws -> [UInt8]
    func `boxSealOpen`(`receiverKey`: AskarLocalKey, `ciphertext`: [UInt8])  throws -> [UInt8]
    func `cryptoBox`(`receiverKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8])  throws -> [UInt8]
    func `randomNonce`()  throws -> [UInt8]
    
}

public class AskarCrypto: AskarCryptoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_aries_askar_fn_constructor_askarcrypto_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarcrypto(pointer, $0) }
    }

    

    
    

    public func `boxOpen`(`receiverKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8]) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarcrypto_box_open(self.pointer, 
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterTypeAskarLocalKey.lower(`senderKey`),
        FfiConverterSequenceUInt8.lower(`message`),
        FfiConverterSequenceUInt8.lower(`nonce`),$0
    )
}
        )
    }

    public func `boxSeal`(`receiverKey`: AskarLocalKey, `message`: [UInt8]) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarcrypto_box_seal(self.pointer, 
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`message`),$0
    )
}
        )
    }

    public func `boxSealOpen`(`receiverKey`: AskarLocalKey, `ciphertext`: [UInt8]) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarcrypto_box_seal_open(self.pointer, 
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`ciphertext`),$0
    )
}
        )
    }

    public func `cryptoBox`(`receiverKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8]) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarcrypto_crypto_box(self.pointer, 
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterTypeAskarLocalKey.lower(`senderKey`),
        FfiConverterSequenceUInt8.lower(`message`),
        FfiConverterSequenceUInt8.lower(`nonce`),$0
    )
}
        )
    }

    public func `randomNonce`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarcrypto_random_nonce(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeAskarCrypto: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarCrypto

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarCrypto {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarCrypto, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarCrypto {
        return AskarCrypto(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarCrypto) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarCrypto_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarCrypto {
    return try FfiConverterTypeAskarCrypto.lift(pointer)
}

public func FfiConverterTypeAskarCrypto_lower(_ value: AskarCrypto) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarCrypto.lower(value)
}


public protocol AskarEcdh1PUProtocol {
    func `decryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8], `aad`: [UInt8]?)  throws -> [UInt8]
    func `deriveKey`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ccTag`: [UInt8], `receive`: Bool)  throws -> AskarLocalKey
    func `encryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8]?, `aad`: [UInt8]?)  throws -> EncryptedBuffer
    func `receiverUnwrapKey`(`wrapAlg`: AskarKeyAlg, `encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `ccTag`: [UInt8], `nonce`: [UInt8]?, `tag`: [UInt8]?)  throws -> AskarLocalKey
    func `senderWrapKey`(`wrapAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `cek`: AskarLocalKey, `ccTag`: [UInt8])  throws -> EncryptedBuffer
    
}

public class AskarEcdh1Pu: AskarEcdh1PUProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`algId`: String, `apu`: String, `apv`: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_aries_askar_fn_constructor_askarecdh1pu_new(
        FfiConverterString.lower(`algId`),
        FfiConverterString.lower(`apu`),
        FfiConverterString.lower(`apv`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarecdh1pu(pointer, $0) }
    }

    

    
    

    public func `decryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8], `aad`: [UInt8]?) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdh1pu_decrypt_direct(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`senderKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`ciphertext`),
        FfiConverterOptionSequenceUInt8.lower(`tag`),
        FfiConverterSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`aad`),$0
    )
}
        )
    }

    public func `deriveKey`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ccTag`: [UInt8], `receive`: Bool) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdh1pu_derive_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`senderKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`ccTag`),
        FfiConverterBool.lower(`receive`),$0
    )
}
        )
    }

    public func `encryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8]?, `aad`: [UInt8]?) throws -> EncryptedBuffer {
        return try  FfiConverterTypeEncryptedBuffer.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdh1pu_encrypt_direct(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`senderKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`message`),
        FfiConverterOptionSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`aad`),$0
    )
}
        )
    }

    public func `receiverUnwrapKey`(`wrapAlg`: AskarKeyAlg, `encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `ccTag`: [UInt8], `nonce`: [UInt8]?, `tag`: [UInt8]?) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdh1pu_receiver_unwrap_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`wrapAlg`),
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`senderKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`ciphertext`),
        FfiConverterSequenceUInt8.lower(`ccTag`),
        FfiConverterOptionSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`tag`),$0
    )
}
        )
    }

    public func `senderWrapKey`(`wrapAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `senderKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `cek`: AskarLocalKey, `ccTag`: [UInt8]) throws -> EncryptedBuffer {
        return try  FfiConverterTypeEncryptedBuffer.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdh1pu_sender_wrap_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`wrapAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`senderKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterTypeAskarLocalKey.lower(`cek`),
        FfiConverterSequenceUInt8.lower(`ccTag`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeAskarEcdh1PU: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEcdh1Pu

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEcdh1Pu {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEcdh1Pu, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdh1Pu {
        return AskarEcdh1Pu(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEcdh1Pu) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarEcdh1PU_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdh1Pu {
    return try FfiConverterTypeAskarEcdh1PU.lift(pointer)
}

public func FfiConverterTypeAskarEcdh1PU_lower(_ value: AskarEcdh1Pu) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEcdh1PU.lower(value)
}


public protocol AskarEcdhEsProtocol {
    func `decryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8], `aad`: [UInt8]?)  throws -> [UInt8]
    func `deriveKey`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `receive`: Bool)  throws -> AskarLocalKey
    func `encryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8]?, `aad`: [UInt8]?)  throws -> EncryptedBuffer
    func `receiverUnwrapKey`(`wrapAlg`: AskarKeyAlg, `encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `nonce`: [UInt8]?, `tag`: [UInt8]?)  throws -> AskarLocalKey
    func `senderWrapKey`(`wrapAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `cek`: AskarLocalKey)  throws -> EncryptedBuffer
    
}

public class AskarEcdhEs: AskarEcdhEsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`algId`: String, `apu`: String, `apv`: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_aries_askar_fn_constructor_askarecdhes_new(
        FfiConverterString.lower(`algId`),
        FfiConverterString.lower(`apu`),
        FfiConverterString.lower(`apv`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarecdhes(pointer, $0) }
    }

    

    
    

    public func `decryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8], `aad`: [UInt8]?) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdhes_decrypt_direct(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`ciphertext`),
        FfiConverterOptionSequenceUInt8.lower(`tag`),
        FfiConverterSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`aad`),$0
    )
}
        )
    }

    public func `deriveKey`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `receive`: Bool) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdhes_derive_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterBool.lower(`receive`),$0
    )
}
        )
    }

    public func `encryptDirect`(`encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `message`: [UInt8], `nonce`: [UInt8]?, `aad`: [UInt8]?) throws -> EncryptedBuffer {
        return try  FfiConverterTypeEncryptedBuffer.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdhes_encrypt_direct(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`message`),
        FfiConverterOptionSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`aad`),$0
    )
}
        )
    }

    public func `receiverUnwrapKey`(`wrapAlg`: AskarKeyAlg, `encAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `ciphertext`: [UInt8], `nonce`: [UInt8]?, `tag`: [UInt8]?) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdhes_receiver_unwrap_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`wrapAlg`),
        FfiConverterTypeAskarKeyAlg.lower(`encAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterSequenceUInt8.lower(`ciphertext`),
        FfiConverterOptionSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`tag`),$0
    )
}
        )
    }

    public func `senderWrapKey`(`wrapAlg`: AskarKeyAlg, `ephemeralKey`: AskarLocalKey, `receiverKey`: AskarLocalKey, `cek`: AskarLocalKey) throws -> EncryptedBuffer {
        return try  FfiConverterTypeEncryptedBuffer.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarecdhes_sender_wrap_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`wrapAlg`),
        FfiConverterTypeAskarLocalKey.lower(`ephemeralKey`),
        FfiConverterTypeAskarLocalKey.lower(`receiverKey`),
        FfiConverterTypeAskarLocalKey.lower(`cek`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeAskarEcdhEs: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEcdhEs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEcdhEs {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEcdhEs, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdhEs {
        return AskarEcdhEs(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEcdhEs) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarEcdhEs_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdhEs {
    return try FfiConverterTypeAskarEcdhEs.lift(pointer)
}

public func FfiConverterTypeAskarEcdhEs_lower(_ value: AskarEcdhEs) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEcdhEs.lower(value)
}


public protocol AskarEntryProtocol {
    func `category`()   -> String
    func `name`()   -> String
    func `tags`()   -> [String: String]
    func `value`()   -> [UInt8]
    
}

public class AskarEntry: AskarEntryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarentry(pointer, $0) }
    }

    

    
    

    public func `category`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarentry_category(self.pointer, $0
    )
}
        )
    }

    public func `name`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarentry_name(self.pointer, $0
    )
}
        )
    }

    public func `tags`()  -> [String: String] {
        return try!  FfiConverterDictionaryStringString.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarentry_tags(self.pointer, $0
    )
}
        )
    }

    public func `value`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarentry_value(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeAskarEntry: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEntry {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEntry, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEntry {
        return AskarEntry(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEntry) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarEntry_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEntry {
    return try FfiConverterTypeAskarEntry.lift(pointer)
}

public func FfiConverterTypeAskarEntry_lower(_ value: AskarEntry) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEntry.lower(value)
}


public protocol AskarKeyEntryProtocol {
    func `algorithm`()   -> String?
    func `isLocal`()   -> Bool
    func `loadLocalKey`()  throws -> AskarLocalKey
    func `metadata`()   -> String?
    func `name`()   -> String
    func `tags`()   -> [String: String]
    
}

public class AskarKeyEntry: AskarKeyEntryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarkeyentry(pointer, $0) }
    }

    

    
    

    public func `algorithm`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarkeyentry_algorithm(self.pointer, $0
    )
}
        )
    }

    public func `isLocal`()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarkeyentry_is_local(self.pointer, $0
    )
}
        )
    }

    public func `loadLocalKey`() throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarkeyentry_load_local_key(self.pointer, $0
    )
}
        )
    }

    public func `metadata`()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarkeyentry_metadata(self.pointer, $0
    )
}
        )
    }

    public func `name`()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarkeyentry_name(self.pointer, $0
    )
}
        )
    }

    public func `tags`()  -> [String: String] {
        return try!  FfiConverterDictionaryStringString.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarkeyentry_tags(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeAskarKeyEntry: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarKeyEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarKeyEntry {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarKeyEntry, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarKeyEntry {
        return AskarKeyEntry(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarKeyEntry) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarKeyEntry_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarKeyEntry {
    return try FfiConverterTypeAskarKeyEntry.lift(pointer)
}

public func FfiConverterTypeAskarKeyEntry_lower(_ value: AskarKeyEntry) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarKeyEntry.lower(value)
}


public protocol AskarLocalKeyProtocol {
    func `aeadDecrypt`(`ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8], `aad`: [UInt8]?)  throws -> [UInt8]
    func `aeadEncrypt`(`message`: [UInt8], `nonce`: [UInt8]?, `aad`: [UInt8]?)  throws -> EncryptedBuffer
    func `aeadPadding`(`msgLen`: Int32)   -> Int32
    func `aeadParams`()  throws -> AeadParams
    func `aeadRandomNonce`()  throws -> [UInt8]
    func `algorithm`()   -> AskarKeyAlg
    func `convertKey`(`alg`: AskarKeyAlg)  throws -> AskarLocalKey
    func `signMessage`(`message`: [UInt8], `sigType`: String?)  throws -> [UInt8]
    func `toJwkPublic`(`alg`: AskarKeyAlg?)  throws -> String
    func `toJwkSecret`()  throws -> [UInt8]
    func `toJwkThumbprint`(`alg`: AskarKeyAlg?)  throws -> String
    func `toJwkThumbprints`()  throws -> [String]
    func `toKeyExchange`(`alg`: AskarKeyAlg, `pk`: AskarLocalKey)  throws -> AskarLocalKey
    func `toPublicBytes`()  throws -> [UInt8]
    func `toSecretBytes`()  throws -> [UInt8]
    func `unwrapKey`(`alg`: AskarKeyAlg, `ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8]?)  throws -> AskarLocalKey
    func `verifySignature`(`message`: [UInt8], `signature`: [UInt8], `sigType`: String?)  throws -> Bool
    func `wrapKey`(`key`: AskarLocalKey, `nonce`: [UInt8]?)  throws -> EncryptedBuffer
    
}

public class AskarLocalKey: AskarLocalKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarlocalkey(pointer, $0) }
    }

    

    
    

    public func `aeadDecrypt`(`ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8], `aad`: [UInt8]?) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_aead_decrypt(self.pointer, 
        FfiConverterSequenceUInt8.lower(`ciphertext`),
        FfiConverterOptionSequenceUInt8.lower(`tag`),
        FfiConverterSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`aad`),$0
    )
}
        )
    }

    public func `aeadEncrypt`(`message`: [UInt8], `nonce`: [UInt8]?, `aad`: [UInt8]?) throws -> EncryptedBuffer {
        return try  FfiConverterTypeEncryptedBuffer.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_aead_encrypt(self.pointer, 
        FfiConverterSequenceUInt8.lower(`message`),
        FfiConverterOptionSequenceUInt8.lower(`nonce`),
        FfiConverterOptionSequenceUInt8.lower(`aad`),$0
    )
}
        )
    }

    public func `aeadPadding`(`msgLen`: Int32)  -> Int32 {
        return try!  FfiConverterInt32.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarlocalkey_aead_padding(self.pointer, 
        FfiConverterInt32.lower(`msgLen`),$0
    )
}
        )
    }

    public func `aeadParams`() throws -> AeadParams {
        return try  FfiConverterTypeAeadParams.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_aead_params(self.pointer, $0
    )
}
        )
    }

    public func `aeadRandomNonce`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_aead_random_nonce(self.pointer, $0
    )
}
        )
    }

    public func `algorithm`()  -> AskarKeyAlg {
        return try!  FfiConverterTypeAskarKeyAlg.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_askarlocalkey_algorithm(self.pointer, $0
    )
}
        )
    }

    public func `convertKey`(`alg`: AskarKeyAlg) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_convert_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`alg`),$0
    )
}
        )
    }

    public func `signMessage`(`message`: [UInt8], `sigType`: String?) throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_sign_message(self.pointer, 
        FfiConverterSequenceUInt8.lower(`message`),
        FfiConverterOptionString.lower(`sigType`),$0
    )
}
        )
    }

    public func `toJwkPublic`(`alg`: AskarKeyAlg?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_public(self.pointer, 
        FfiConverterOptionTypeAskarKeyAlg.lower(`alg`),$0
    )
}
        )
    }

    public func `toJwkSecret`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_secret(self.pointer, $0
    )
}
        )
    }

    public func `toJwkThumbprint`(`alg`: AskarKeyAlg?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_thumbprint(self.pointer, 
        FfiConverterOptionTypeAskarKeyAlg.lower(`alg`),$0
    )
}
        )
    }

    public func `toJwkThumbprints`() throws -> [String] {
        return try  FfiConverterSequenceString.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_to_jwk_thumbprints(self.pointer, $0
    )
}
        )
    }

    public func `toKeyExchange`(`alg`: AskarKeyAlg, `pk`: AskarLocalKey) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_to_key_exchange(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`alg`),
        FfiConverterTypeAskarLocalKey.lower(`pk`),$0
    )
}
        )
    }

    public func `toPublicBytes`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_to_public_bytes(self.pointer, $0
    )
}
        )
    }

    public func `toSecretBytes`() throws -> [UInt8] {
        return try  FfiConverterSequenceUInt8.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_to_secret_bytes(self.pointer, $0
    )
}
        )
    }

    public func `unwrapKey`(`alg`: AskarKeyAlg, `ciphertext`: [UInt8], `tag`: [UInt8]?, `nonce`: [UInt8]?) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_unwrap_key(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`alg`),
        FfiConverterSequenceUInt8.lower(`ciphertext`),
        FfiConverterOptionSequenceUInt8.lower(`tag`),
        FfiConverterOptionSequenceUInt8.lower(`nonce`),$0
    )
}
        )
    }

    public func `verifySignature`(`message`: [UInt8], `signature`: [UInt8], `sigType`: String?) throws -> Bool {
        return try  FfiConverterBool.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_verify_signature(self.pointer, 
        FfiConverterSequenceUInt8.lower(`message`),
        FfiConverterSequenceUInt8.lower(`signature`),
        FfiConverterOptionString.lower(`sigType`),$0
    )
}
        )
    }

    public func `wrapKey`(`key`: AskarLocalKey, `nonce`: [UInt8]?) throws -> EncryptedBuffer {
        return try  FfiConverterTypeEncryptedBuffer.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarlocalkey_wrap_key(self.pointer, 
        FfiConverterTypeAskarLocalKey.lower(`key`),
        FfiConverterOptionSequenceUInt8.lower(`nonce`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeAskarLocalKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarLocalKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarLocalKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarLocalKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarLocalKey {
        return AskarLocalKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarLocalKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarLocalKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarLocalKey {
    return try FfiConverterTypeAskarLocalKey.lift(pointer)
}

public func FfiConverterTypeAskarLocalKey_lower(_ value: AskarLocalKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarLocalKey.lower(value)
}


public protocol AskarScanProtocol {
    func `fetchAll`() async throws -> [AskarEntry]
    func `next`() async throws -> [AskarEntry]?
    
}

public class AskarScan: AskarScanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarscan(pointer, $0) }
    }

    

    
    

    public func `fetchAll`() async throws -> [AskarEntry] {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<[AskarEntry], Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarscan_fetch_all(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerSequenceTypeAskarEntryTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `next`() async throws -> [AskarEntry]? {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<[AskarEntry]?, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarscan_next(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerOptionSequenceTypeAskarEntryTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeAskarScan: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarScan

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarScan {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarScan, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarScan {
        return AskarScan(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarScan) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarScan_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarScan {
    return try FfiConverterTypeAskarScan.lift(pointer)
}

public func FfiConverterTypeAskarScan_lower(_ value: AskarScan) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarScan.lower(value)
}


public protocol AskarSessionProtocol {
    func `close`() async throws
    func `count`(`category`: String, `tagFilter`: String?) async throws -> Int64
    func `fetch`(`category`: String, `name`: String, `forUpdate`: Bool) async throws -> AskarEntry?
    func `fetchAll`(`category`: String, `tagFilter`: String?, `limit`: Int64?, `forUpdate`: Bool) async throws -> [AskarEntry]
    func `fetchAllKeys`(`algorithm`: String?, `thumbprint`: String?, `tagFilter`: String?, `limit`: Int64?, `forUpdate`: Bool) async throws -> [AskarKeyEntry]
    func `fetchKey`(`name`: String, `forUpdate`: Bool) async throws -> AskarKeyEntry?
    func `insertKey`(`name`: String, `key`: AskarLocalKey, `metadata`: String?, `tags`: String?, `expiryMs`: Int64?) async throws
    func `removeAll`(`category`: String, `tagFilter`: String?) async throws -> Int64
    func `removeKey`(`name`: String) async throws
    func `update`(`operation`: AskarEntryOperation, `category`: String, `name`: String, `value`: [UInt8], `tags`: String?, `expiryMs`: Int64?) async throws
    func `updateKey`(`name`: String, `metadata`: String?, `tags`: String?, `expiryMs`: Int64?) async throws
    
}

public class AskarSession: AskarSessionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarsession(pointer, $0) }
    }

    

    
    

    public func `close`() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_close(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `count`(`category`: String, `tagFilter`: String?) async throws -> Int64 {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Int64, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_count(
                    self.pointer,
                    
        FfiConverterString.lower(`category`),
        FfiConverterOptionString.lower(`tagFilter`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerInt64TypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `fetch`(`category`: String, `name`: String, `forUpdate`: Bool) async throws -> AskarEntry? {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<AskarEntry?, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_fetch(
                    self.pointer,
                    
        FfiConverterString.lower(`category`),
        FfiConverterString.lower(`name`),
        FfiConverterBool.lower(`forUpdate`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerOptionTypeAskarEntryTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `fetchAll`(`category`: String, `tagFilter`: String?, `limit`: Int64?, `forUpdate`: Bool) async throws -> [AskarEntry] {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<[AskarEntry], Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_fetch_all(
                    self.pointer,
                    
        FfiConverterString.lower(`category`),
        FfiConverterOptionString.lower(`tagFilter`),
        FfiConverterOptionInt64.lower(`limit`),
        FfiConverterBool.lower(`forUpdate`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerSequenceTypeAskarEntryTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `fetchAllKeys`(`algorithm`: String?, `thumbprint`: String?, `tagFilter`: String?, `limit`: Int64?, `forUpdate`: Bool) async throws -> [AskarKeyEntry] {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<[AskarKeyEntry], Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_fetch_all_keys(
                    self.pointer,
                    
        FfiConverterOptionString.lower(`algorithm`),
        FfiConverterOptionString.lower(`thumbprint`),
        FfiConverterOptionString.lower(`tagFilter`),
        FfiConverterOptionInt64.lower(`limit`),
        FfiConverterBool.lower(`forUpdate`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerSequenceTypeAskarKeyEntryTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `fetchKey`(`name`: String, `forUpdate`: Bool) async throws -> AskarKeyEntry? {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<AskarKeyEntry?, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_fetch_key(
                    self.pointer,
                    
        FfiConverterString.lower(`name`),
        FfiConverterBool.lower(`forUpdate`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerOptionTypeAskarKeyEntryTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `insertKey`(`name`: String, `key`: AskarLocalKey, `metadata`: String?, `tags`: String?, `expiryMs`: Int64?) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_insert_key(
                    self.pointer,
                    
        FfiConverterString.lower(`name`),
        FfiConverterTypeAskarLocalKey.lower(`key`),
        FfiConverterOptionString.lower(`metadata`),
        FfiConverterOptionString.lower(`tags`),
        FfiConverterOptionInt64.lower(`expiryMs`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `removeAll`(`category`: String, `tagFilter`: String?) async throws -> Int64 {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Int64, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_remove_all(
                    self.pointer,
                    
        FfiConverterString.lower(`category`),
        FfiConverterOptionString.lower(`tagFilter`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerInt64TypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `removeKey`(`name`: String) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_remove_key(
                    self.pointer,
                    
        FfiConverterString.lower(`name`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `update`(`operation`: AskarEntryOperation, `category`: String, `name`: String, `value`: [UInt8], `tags`: String?, `expiryMs`: Int64?) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_update(
                    self.pointer,
                    
        FfiConverterTypeAskarEntryOperation.lower(`operation`),
        FfiConverterString.lower(`category`),
        FfiConverterString.lower(`name`),
        FfiConverterSequenceUInt8.lower(`value`),
        FfiConverterOptionString.lower(`tags`),
        FfiConverterOptionInt64.lower(`expiryMs`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `updateKey`(`name`: String, `metadata`: String?, `tags`: String?, `expiryMs`: Int64?) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarsession_update_key(
                    self.pointer,
                    
        FfiConverterString.lower(`name`),
        FfiConverterOptionString.lower(`metadata`),
        FfiConverterOptionString.lower(`tags`),
        FfiConverterOptionInt64.lower(`expiryMs`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeAskarSession: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarSession

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarSession {
        return AskarSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarSession) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarSession {
    return try FfiConverterTypeAskarSession.lift(pointer)
}

public func FfiConverterTypeAskarSession_lower(_ value: AskarSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarSession.lower(value)
}


public protocol AskarStoreProtocol {
    func `close`() async throws
    func `createProfile`(`profile`: String?) async throws -> String
    func `getProfileName`() async throws -> String
    func `rekey`(`keyMethod`: String?, `passKey`: String?) async throws
    func `removeProfile`(`profile`: String) async throws -> Bool
    func `scan`(`profile`: String?, `categogy`: String, `tagFilter`: String?, `offset`: Int64?, `limit`: Int64?) async throws -> AskarScan
    func `session`(`profile`: String?) async throws -> AskarSession
    
}

public class AskarStore: AskarStoreProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarstore(pointer, $0) }
    }

    

    
    

    public func `close`() async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstore_close(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `createProfile`(`profile`: String?) async throws -> String {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<String, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstore_create_profile(
                    self.pointer,
                    
        FfiConverterOptionString.lower(`profile`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerStringTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `getProfileName`() async throws -> String {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<String, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstore_get_profile_name(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerStringTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `rekey`(`keyMethod`: String?, `passKey`: String?) async throws {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstore_rekey(
                    self.pointer,
                    
        FfiConverterOptionString.lower(`keyMethod`),
        FfiConverterOptionString.lower(`passKey`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoidTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `removeProfile`(`profile`: String) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstore_remove_profile(
                    self.pointer,
                    
        FfiConverterString.lower(`profile`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `scan`(`profile`: String?, `categogy`: String, `tagFilter`: String?, `offset`: Int64?, `limit`: Int64?) async throws -> AskarScan {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<AskarScan, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstore_scan(
                    self.pointer,
                    
        FfiConverterOptionString.lower(`profile`),
        FfiConverterString.lower(`categogy`),
        FfiConverterOptionString.lower(`tagFilter`),
        FfiConverterOptionInt64.lower(`offset`),
        FfiConverterOptionInt64.lower(`limit`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeAskarScanTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `session`(`profile`: String?) async throws -> AskarSession {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<AskarSession, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstore_session(
                    self.pointer,
                    
        FfiConverterOptionString.lower(`profile`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeAskarSessionTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeAskarStore: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarStore

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarStore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarStore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStore {
        return AskarStore(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarStore) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarStore_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStore {
    return try FfiConverterTypeAskarStore.lift(pointer)
}

public func FfiConverterTypeAskarStore_lower(_ value: AskarStore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarStore.lower(value)
}


public protocol AskarStoreManagerProtocol {
    func `generateRawStoreKey`(`seed`: String?)  throws -> String
    func `open`(`specUri`: String, `keyMethod`: String?, `passKey`: String?, `profile`: String?) async throws -> AskarStore
    func `provision`(`specUri`: String, `keyMethod`: String?, `passKey`: String?, `profile`: String?, `recreate`: Bool) async throws -> AskarStore
    func `remove`(`specUri`: String) async throws -> Bool
    func `setDefaultLogger`()  throws
    
}

public class AskarStoreManager: AskarStoreManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_aries_askar_fn_constructor_askarstoremanager_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_askarstoremanager(pointer, $0) }
    }

    

    
    

    public func `generateRawStoreKey`(`seed`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarstoremanager_generate_raw_store_key(self.pointer, 
        FfiConverterOptionString.lower(`seed`),$0
    )
}
        )
    }

    public func `open`(`specUri`: String, `keyMethod`: String?, `passKey`: String?, `profile`: String?) async throws -> AskarStore {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<AskarStore, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstoremanager_open(
                    self.pointer,
                    
        FfiConverterString.lower(`specUri`),
        FfiConverterOptionString.lower(`keyMethod`),
        FfiConverterOptionString.lower(`passKey`),
        FfiConverterOptionString.lower(`profile`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeAskarStoreTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `provision`(`specUri`: String, `keyMethod`: String?, `passKey`: String?, `profile`: String?, `recreate`: Bool) async throws -> AskarStore {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<AskarStore, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstoremanager_provision(
                    self.pointer,
                    
        FfiConverterString.lower(`specUri`),
        FfiConverterOptionString.lower(`keyMethod`),
        FfiConverterOptionString.lower(`passKey`),
        FfiConverterOptionString.lower(`profile`),
        FfiConverterBool.lower(`recreate`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerTypeAskarStoreTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `remove`(`specUri`: String) async throws -> Bool {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<Bool, Error>? = nil
        return try  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_aries_askar_fn_method_askarstoremanager_remove(
                    self.pointer,
                    
        FfiConverterString.lower(`specUri`),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerBoolTypeErrorCode,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func `setDefaultLogger`() throws {
        try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_askarstoremanager_set_default_logger(self.pointer, $0
    )
}
    }
}

public struct FfiConverterTypeAskarStoreManager: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarStoreManager

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarStoreManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarStoreManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStoreManager {
        return AskarStoreManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarStoreManager) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeAskarStoreManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStoreManager {
    return try FfiConverterTypeAskarStoreManager.lift(pointer)
}

public func FfiConverterTypeAskarStoreManager_lower(_ value: AskarStoreManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarStoreManager.lower(value)
}


public protocol EncryptedBufferProtocol {
    func `ciphertext`()   -> [UInt8]
    func `ciphertextTag`()   -> [UInt8]
    func `nonce`()   -> [UInt8]
    func `tag`()   -> [UInt8]
    
}

public class EncryptedBuffer: EncryptedBufferProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_encryptedbuffer(pointer, $0) }
    }

    

    
    

    public func `ciphertext`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_encryptedbuffer_ciphertext(self.pointer, $0
    )
}
        )
    }

    public func `ciphertextTag`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_encryptedbuffer_ciphertext_tag(self.pointer, $0
    )
}
        )
    }

    public func `nonce`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_encryptedbuffer_nonce(self.pointer, $0
    )
}
        )
    }

    public func `tag`()  -> [UInt8] {
        return try!  FfiConverterSequenceUInt8.lift(
            try! 
    rustCall() {
    
    uniffi_aries_askar_fn_method_encryptedbuffer_tag(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeEncryptedBuffer: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EncryptedBuffer

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedBuffer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EncryptedBuffer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedBuffer {
        return EncryptedBuffer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EncryptedBuffer) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeEncryptedBuffer_lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedBuffer {
    return try FfiConverterTypeEncryptedBuffer.lift(pointer)
}

public func FfiConverterTypeEncryptedBuffer_lower(_ value: EncryptedBuffer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEncryptedBuffer.lower(value)
}


public protocol LocalKeyFactoryProtocol {
    func `fromJwk`(`jwk`: String)  throws -> AskarLocalKey
    func `fromJwkSlice`(`jwk`: [UInt8])  throws -> AskarLocalKey
    func `fromPublicBytes`(`alg`: AskarKeyAlg, `bytes`: [UInt8])  throws -> AskarLocalKey
    func `fromSecretBytes`(`alg`: AskarKeyAlg, `bytes`: [UInt8])  throws -> AskarLocalKey
    func `fromSeed`(`alg`: AskarKeyAlg, `seed`: [UInt8], `method`: SeedMethod?)  throws -> AskarLocalKey
    func `generate`(`alg`: AskarKeyAlg, `ephemeral`: Bool)  throws -> AskarLocalKey
    
}

public class LocalKeyFactory: LocalKeyFactoryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_aries_askar_fn_constructor_localkeyfactory_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_aries_askar_fn_free_localkeyfactory(pointer, $0) }
    }

    

    
    

    public func `fromJwk`(`jwk`: String) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_localkeyfactory_from_jwk(self.pointer, 
        FfiConverterString.lower(`jwk`),$0
    )
}
        )
    }

    public func `fromJwkSlice`(`jwk`: [UInt8]) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_localkeyfactory_from_jwk_slice(self.pointer, 
        FfiConverterSequenceUInt8.lower(`jwk`),$0
    )
}
        )
    }

    public func `fromPublicBytes`(`alg`: AskarKeyAlg, `bytes`: [UInt8]) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_localkeyfactory_from_public_bytes(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`alg`),
        FfiConverterSequenceUInt8.lower(`bytes`),$0
    )
}
        )
    }

    public func `fromSecretBytes`(`alg`: AskarKeyAlg, `bytes`: [UInt8]) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_localkeyfactory_from_secret_bytes(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`alg`),
        FfiConverterSequenceUInt8.lower(`bytes`),$0
    )
}
        )
    }

    public func `fromSeed`(`alg`: AskarKeyAlg, `seed`: [UInt8], `method`: SeedMethod?) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_localkeyfactory_from_seed(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`alg`),
        FfiConverterSequenceUInt8.lower(`seed`),
        FfiConverterOptionTypeSeedMethod.lower(`method`),$0
    )
}
        )
    }

    public func `generate`(`alg`: AskarKeyAlg, `ephemeral`: Bool) throws -> AskarLocalKey {
        return try  FfiConverterTypeAskarLocalKey.lift(
            try 
    rustCallWithError(FfiConverterTypeErrorCode.lift) {
    uniffi_aries_askar_fn_method_localkeyfactory_generate(self.pointer, 
        FfiConverterTypeAskarKeyAlg.lower(`alg`),
        FfiConverterBool.lower(`ephemeral`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeLocalKeyFactory: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LocalKeyFactory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalKeyFactory {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LocalKeyFactory, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalKeyFactory {
        return LocalKeyFactory(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LocalKeyFactory) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeLocalKeyFactory_lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalKeyFactory {
    return try FfiConverterTypeLocalKeyFactory.lift(pointer)
}

public func FfiConverterTypeLocalKeyFactory_lower(_ value: LocalKeyFactory) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLocalKeyFactory.lower(value)
}

// Encapsulates an executor that can run Rust tasks
//
// On Swift, `Task.detached` can handle this we just need to know what priority to send it.
public struct UniFfiForeignExecutor {
    var priority: TaskPriority

    public init(priority: TaskPriority) {
        self.priority = priority
    }

    public init() {
        self.priority = Task.currentPriority
    }
}

fileprivate struct FfiConverterForeignExecutor: FfiConverter {
    typealias SwiftType = UniFfiForeignExecutor
    // Rust uses a pointer to represent the FfiConverterForeignExecutor, but we only need a u8. 
    // let's use `Int`, which is equivalent to `size_t`
    typealias FfiType = Int

    static func lift(_ value: FfiType) throws -> SwiftType {
        UniFfiForeignExecutor(priority: TaskPriority(rawValue: numericCast(value)))
    }
    static func lower(_ value: SwiftType) -> FfiType {
        numericCast(value.priority.rawValue)
    }

    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        fatalError("FfiConverterForeignExecutor.read not implemented yet")
    }
    static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        fatalError("FfiConverterForeignExecutor.read not implemented yet")
    }
}


fileprivate func uniffiForeignExecutorCallback(executorHandle: Int, delayMs: UInt32, rustTask: UniFfiRustTaskCallback?, taskData: UnsafeRawPointer?) {
    if let rustTask = rustTask {
        let executor = try! FfiConverterForeignExecutor.lift(executorHandle)
        Task.detached(priority: executor.priority) {
            if delayMs != 0 {
                let nanoseconds: UInt64 = numericCast(delayMs * 1000000)
                try! await Task.sleep(nanoseconds: nanoseconds)
            }
            rustTask(taskData)
        }

    }
    // No else branch: when rustTask is null, we should drop the foreign executor. However, since
    // its just a value type, we don't need to do anything here.
}

fileprivate func uniffiInitForeignExecutor() {
    uniffi_foreign_executor_callback_set(uniffiForeignExecutorCallback)
}


public struct AeadParams {
    public var `nonceLength`: Int32
    public var `tagLength`: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`nonceLength`: Int32, `tagLength`: Int32) {
        self.`nonceLength` = `nonceLength`
        self.`tagLength` = `tagLength`
    }
}


extension AeadParams: Equatable, Hashable {
    public static func ==(lhs: AeadParams, rhs: AeadParams) -> Bool {
        if lhs.`nonceLength` != rhs.`nonceLength` {
            return false
        }
        if lhs.`tagLength` != rhs.`tagLength` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`nonceLength`)
        hasher.combine(`tagLength`)
    }
}


public struct FfiConverterTypeAeadParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AeadParams {
        return try AeadParams(
            `nonceLength`: FfiConverterInt32.read(from: &buf), 
            `tagLength`: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: AeadParams, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.`nonceLength`, into: &buf)
        FfiConverterInt32.write(value.`tagLength`, into: &buf)
    }
}


public func FfiConverterTypeAeadParams_lift(_ buf: RustBuffer) throws -> AeadParams {
    return try FfiConverterTypeAeadParams.lift(buf)
}

public func FfiConverterTypeAeadParams_lower(_ value: AeadParams) -> RustBuffer {
    return FfiConverterTypeAeadParams.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AskarEntryOperation {
    
    case `insert`
    case `replace`
    case `remove`
}

public struct FfiConverterTypeAskarEntryOperation: FfiConverterRustBuffer {
    typealias SwiftType = AskarEntryOperation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEntryOperation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`insert`
        
        case 2: return .`replace`
        
        case 3: return .`remove`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AskarEntryOperation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`insert`:
            writeInt(&buf, Int32(1))
        
        
        case .`replace`:
            writeInt(&buf, Int32(2))
        
        
        case .`remove`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeAskarEntryOperation_lift(_ buf: RustBuffer) throws -> AskarEntryOperation {
    return try FfiConverterTypeAskarEntryOperation.lift(buf)
}

public func FfiConverterTypeAskarEntryOperation_lower(_ value: AskarEntryOperation) -> RustBuffer {
    return FfiConverterTypeAskarEntryOperation.lower(value)
}


extension AskarEntryOperation: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AskarKeyAlg {
    
    case `a128Gcm`
    case `a256Gcm`
    case `a128CbcHs256`
    case `a256CbcHs512`
    case `a128Kw`
    case `a256Kw`
    case `bls12381g1`
    case `bls12381g2`
    case `bls12381g1g2`
    case `c20p`
    case `xc20p`
    case `ed25519`
    case `x25519`
    case `k256`
    case `p256`
    case `p384`
}

public struct FfiConverterTypeAskarKeyAlg: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyAlg

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarKeyAlg {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`a128Gcm`
        
        case 2: return .`a256Gcm`
        
        case 3: return .`a128CbcHs256`
        
        case 4: return .`a256CbcHs512`
        
        case 5: return .`a128Kw`
        
        case 6: return .`a256Kw`
        
        case 7: return .`bls12381g1`
        
        case 8: return .`bls12381g2`
        
        case 9: return .`bls12381g1g2`
        
        case 10: return .`c20p`
        
        case 11: return .`xc20p`
        
        case 12: return .`ed25519`
        
        case 13: return .`x25519`
        
        case 14: return .`k256`
        
        case 15: return .`p256`
        
        case 16: return .`p384`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AskarKeyAlg, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`a128Gcm`:
            writeInt(&buf, Int32(1))
        
        
        case .`a256Gcm`:
            writeInt(&buf, Int32(2))
        
        
        case .`a128CbcHs256`:
            writeInt(&buf, Int32(3))
        
        
        case .`a256CbcHs512`:
            writeInt(&buf, Int32(4))
        
        
        case .`a128Kw`:
            writeInt(&buf, Int32(5))
        
        
        case .`a256Kw`:
            writeInt(&buf, Int32(6))
        
        
        case .`bls12381g1`:
            writeInt(&buf, Int32(7))
        
        
        case .`bls12381g2`:
            writeInt(&buf, Int32(8))
        
        
        case .`bls12381g1g2`:
            writeInt(&buf, Int32(9))
        
        
        case .`c20p`:
            writeInt(&buf, Int32(10))
        
        
        case .`xc20p`:
            writeInt(&buf, Int32(11))
        
        
        case .`ed25519`:
            writeInt(&buf, Int32(12))
        
        
        case .`x25519`:
            writeInt(&buf, Int32(13))
        
        
        case .`k256`:
            writeInt(&buf, Int32(14))
        
        
        case .`p256`:
            writeInt(&buf, Int32(15))
        
        
        case .`p384`:
            writeInt(&buf, Int32(16))
        
        }
    }
}


public func FfiConverterTypeAskarKeyAlg_lift(_ buf: RustBuffer) throws -> AskarKeyAlg {
    return try FfiConverterTypeAskarKeyAlg.lift(buf)
}

public func FfiConverterTypeAskarKeyAlg_lower(_ value: AskarKeyAlg) -> RustBuffer {
    return FfiConverterTypeAskarKeyAlg.lower(value)
}


extension AskarKeyAlg: Equatable, Hashable {}



public enum ErrorCode {

    
    
    case Success(`message`: String)
    case Backend(`message`: String)
    case Busy(`message`: String)
    case Duplicate(`message`: String)
    case Encryption(`message`: String)
    case Input(`message`: String)
    case NotFound(`message`: String)
    case Unexpected(`message`: String)
    case Unsupported(`message`: String)
    case Custom(`message`: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeErrorCode.lift(error)
    }
}


public struct FfiConverterTypeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = ErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Success(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Backend(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Busy(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Duplicate(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 5: return .Encryption(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 6: return .Input(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 7: return .NotFound(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 8: return .Unexpected(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Unsupported(
            `message`: try FfiConverterString.read(from: &buf)
            )
        case 10: return .Custom(
            `message`: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorCode, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Success(`message`):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Backend(`message`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Busy(`message`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Duplicate(`message`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Encryption(`message`):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Input(`message`):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .NotFound(`message`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Unexpected(`message`):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Unsupported(`message`):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(`message`, into: &buf)
            
        
        case let .Custom(`message`):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(`message`, into: &buf)
            
        }
    }
}


extension ErrorCode: Equatable, Hashable {}

extension ErrorCode: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SeedMethod {
    
    case `blsKeyGen`
}

public struct FfiConverterTypeSeedMethod: FfiConverterRustBuffer {
    typealias SwiftType = SeedMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`blsKeyGen`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SeedMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`blsKeyGen`:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeSeedMethod_lift(_ buf: RustBuffer) throws -> SeedMethod {
    return try FfiConverterTypeSeedMethod.lift(buf)
}

public func FfiConverterTypeSeedMethod_lower(_ value: SeedMethod) -> RustBuffer {
    return FfiConverterTypeSeedMethod.lower(value)
}


extension SeedMethod: Equatable, Hashable {}



fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = AskarEntry?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAskarKeyEntry: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyEntry?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarKeyEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarKeyEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAskarKeyAlg: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyAlg?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarKeyAlg.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarKeyAlg.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSeedMethod: FfiConverterRustBuffer {
    typealias SwiftType = SeedMethod?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSeedMethod.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSeedMethod.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarEntry]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAskarEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAskarEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt8: FfiConverterRustBuffer {
    typealias SwiftType = [UInt8]

    public static func write(_ value: [UInt8], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt8.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt8] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt8]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt8.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarEntry]

    public static func write(_ value: [AskarEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAskarEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AskarEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [AskarEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAskarEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAskarKeyEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarKeyEntry]

    public static func write(_ value: [AskarKeyEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAskarKeyEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AskarKeyEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [AskarKeyEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAskarKeyEntry.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}// Callbacks for async functions

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureCallbackHandlerVoidTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerInt32(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int32,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Int32, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterInt32.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerInt64TypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int64,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Int64, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterInt64.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerBool(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Bool, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterBool.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerBoolTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Bool, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterBool.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerStringTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarCrypto(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarCrypto, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarCrypto.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarEcdh1PU(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarEcdh1Pu, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarEcdh1PU.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarEcdhEs(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarEcdhEs, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarEcdhEs.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarLocalKeyTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarLocalKey, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarLocalKey.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarScanTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarScan, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarScan.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarSessionTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarSession, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarSession.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarStoreTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarStore, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarStore.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarStoreManager(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarStoreManager, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarStoreManager.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeEncryptedBufferTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<EncryptedBuffer, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeEncryptedBuffer.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeLocalKeyFactory(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<LocalKeyFactory, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeLocalKeyFactory.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAeadParamsTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AeadParams, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterTypeAeadParams.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeAskarKeyAlg(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarKeyAlg, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeAskarKeyAlg.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeAskarEntryTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarEntry?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeAskarEntry.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeAskarKeyEntryTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<AskarKeyEntry?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeAskarKeyEntry.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionSequenceTypeAskarEntryTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[AskarEntry]?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterOptionSequenceTypeAskarEntry.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceUInt8(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[UInt8], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceUInt8.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceUInt8TypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[UInt8], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterSequenceUInt8.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceStringTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[String], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterSequenceString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeAskarEntryTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[AskarEntry], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeAskarEntry.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeAskarKeyEntryTypeErrorCode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[AskarKeyEntry], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: FfiConverterTypeErrorCode.lift)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeAskarKeyEntry.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerDictionaryStringString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[String: String], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterDictionaryStringString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_aries_askar_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarentry_category() != 3260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarentry_name() != 32165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarentry_tags() != 25644) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarentry_value() != 15374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarkeyentry_algorithm() != 49759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarkeyentry_is_local() != 55452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarkeyentry_load_local_key() != 54061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarkeyentry_metadata() != 37970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarkeyentry_name() != 37206) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarkeyentry_tags() != 44110) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarscan_fetch_all() != 38256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarscan_next() != 61044) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_close() != 21663) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_count() != 23751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_fetch() != 15446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_fetch_all() != 14311) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_fetch_all_keys() != 20309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_fetch_key() != 29640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_insert_key() != 50809) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_remove_all() != 30181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_remove_key() != 7409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_update() != 45947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarsession_update_key() != 58440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstore_close() != 5720) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstore_create_profile() != 52699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstore_get_profile_name() != 43933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstore_rekey() != 35956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstore_remove_profile() != 36069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstore_scan() != 18668) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstore_session() != 46605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_aead_decrypt() != 28744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_aead_encrypt() != 26220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_aead_padding() != 19466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_aead_params() != 51278) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_aead_random_nonce() != 61893) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_algorithm() != 53705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_convert_key() != 35516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_sign_message() != 39020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_public() != 54824) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_secret() != 54958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_thumbprint() != 30788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_to_jwk_thumbprints() != 2898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_to_key_exchange() != 29493) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_to_public_bytes() != 10734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_to_secret_bytes() != 33910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_unwrap_key() != 32063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_verify_signature() != 24569) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarlocalkey_wrap_key() != 48354) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_encryptedbuffer_ciphertext() != 25707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_encryptedbuffer_ciphertext_tag() != 4068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_encryptedbuffer_nonce() != 58146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_encryptedbuffer_tag() != 5792) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_localkeyfactory_from_jwk() != 44160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_localkeyfactory_from_jwk_slice() != 57872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_localkeyfactory_from_public_bytes() != 47192) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_localkeyfactory_from_secret_bytes() != 44895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_localkeyfactory_from_seed() != 47817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_localkeyfactory_generate() != 15969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstoremanager_generate_raw_store_key() != 65070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstoremanager_open() != 59212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstoremanager_provision() != 51063) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstoremanager_remove() != 60582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarstoremanager_set_default_logger() != 42575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarcrypto_box_open() != 21968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarcrypto_box_seal() != 6843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarcrypto_box_seal_open() != 65089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarcrypto_crypto_box() != 6491) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarcrypto_random_nonce() != 3121) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdhes_decrypt_direct() != 57738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdhes_derive_key() != 30605) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdhes_encrypt_direct() != 39447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdhes_receiver_unwrap_key() != 44741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdhes_sender_wrap_key() != 43003) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdh1pu_decrypt_direct() != 45235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdh1pu_derive_key() != 856) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdh1pu_encrypt_direct() != 19815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdh1pu_receiver_unwrap_key() != 16953) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_aries_askar_checksum_method_askarecdh1pu_sender_wrap_key() != 48518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_constructor_localkeyfactory_new() != 64154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_constructor_askarstoremanager_new() != 57892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_constructor_askarcrypto_new() != 42300) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_constructor_askarecdhes_new() != 15713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi__checksum_constructor_askarecdh1pu_new() != 32728) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiInitForeignExecutor()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}